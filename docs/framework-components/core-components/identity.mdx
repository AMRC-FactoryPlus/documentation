---
sidebar_position: 1
---

# Identity

export const ComponentOverview = () => (
    <div className="mb-10 mx-auto text-center w-full flex justify-center">
        <div className="p-4 bg-brand-80 dark:bg-brand-40 dark:text-brand text-white w-[3vw] flex items-center justify-end" style={{writingMode: "vertical-lr"}}>Identity</div>
        <div className="flex flex-col">
            <div className="p-4 bg-brand-80 dark:bg-brand-40 dark:text-brand text-white h-[3vw]"></div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand opacity-40 flex-1 mt-2 ml-2 w-[3vw] flex items-center justify-end" style={{writingMode: "vertical-lr"}}>Authorisation</div>
        </div>
        <div className="grid grid-cols-5 gap-2">
            <div className="p-4 bg-brand-80 dark:bg-brand-40 dark:text-brand text-white col-span-full h-[3vw] flex items-center justify-end">Identity</div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand opacity-40 col-span-full h-[3vw] flex items-center justify-end">Authorisation</div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand flex items-center justify-center ml-2 opacity-40">Directory</div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand flex items-center justify-center opacity-40">Configuration Store</div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand flex items-center justify-center opacity-40">Manager</div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand flex items-center justify-center opacity-40">Commands</div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand flex items-center justify-center opacity-40">Data Warehouse</div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand flex items-center justify-center opacity-40 col-span-full ml-2">MQTT</div>
            <div className="p-4 bg-brand-20 dark:bg-brand-90 dark:text-white text-brand flex items-center justify-center opacity-40 col-span-full ml-2">Edge Agents</div>
        </div>
    </div>
);

Factory+ utilises [Kerberos](https://web.mit.edu/kerberos/) as its identity provider to enhance the security and authentication processes within the architecture. By utilising Kerberos, Factory+ ensures that users and services can authenticate themselves in a secure and reliable manner, while also allowing for seamless integration with external systems that rely on the same authentication mechanism and/or other Factory+ deployments.

<OpenSourceExample buttonText={'ACS Identity Component'} repoUrl={'https://github.com/AMRC-FactoryPlus/acs-identity'}></OpenSourceExample>

## Overview

<ComponentOverview></ComponentOverview>

Kerberos is a network authentication protocol designed to provide strong, secure authentication for client-server applications. It was developed at the Massachusetts Institute of Technology (MIT) in the 1980s and has become a widely adopted standard for secure authentication in various systems, including Windows domains and Unix environments.

The key features of Kerberos include:

- **Mutual Authentication**: Kerberos ensures that both the client and server can verify each other's identity, preventing potential attacks like eavesdropping, man-in-the-middle, and impersonation.
- **Single Sign-On (SSO)**: Once a user has authenticated with Kerberos, they can access multiple services and applications within the network without having to re-authenticate, simplifying the user experience and reducing the need for multiple sets of credentials.
- **Symmetric Key Cryptography**: Kerberos uses symmetric key cryptography for encrypting and decrypting messages between clients and servers, ensuring the confidentiality and integrity of data.
- **Ticket-Based Authentication**: The core concept of Kerberos is the use of "tickets" to grant access to services. When a user authenticates with the Kerberos Key Distribution Center (KDC), they receive a Ticket Granting Ticket (TGT), which can then be used to request service-specific tickets without requiring further authentication.
- **Scalability**: Kerberos is designed to support large-scale networks with numerous clients and services, making it suitable for various organisational sizes and structures.
- **Cross-realm authentication**: Kerberos allows different authentication realms (potentially in different organisations) to set up limited trust arrangements, such that clients from one realm can be granted access to services in another.

For more information on Kerberos, [view the documentation](https://web.mit.edu/kerberos/) on the MIT website.

## Kubernetes integration

In order to ease the management of a Kerberos KDC located within a Kubernetes cluster, we have implemented a k8s operator that allows Kerberos principals to be managed via k8s objects. A Kubernetes object is created requesting that a certain principal should exist in the KDC, and the operator ensures that the principal exists and synchronises the secret key for the principal with Kubernetes secrets.

## Cross-realm authentication

### Basic concepts

Setting up a cross-realm trust in Kerberos is conceptually very simple: a Kerberos ticket-granting principal is created, with a name linking the two realms, and the password for that principal is shared between the two KDCs. The trust is one-way: a given cross-realm ticket-granting principal will allow clients from one realm to authenticate to servers from the other, but not the other way around. If two-way trust is desired then two trust relationships must be created.

One very important point to note here is that all the cross-realm trust allows a client to do is to prove its identity to the server. Whether the client is actually allowed to do anything is the responsibility of the service concerned, and remains entirely under the control of the service's local administration.

Suppose a client in the `ALICE` realm, `alice@ALICE`, wishes to communicate with the MQTT server `mqtt.bob`, which is in the `BOB` realm and has server principal name `mqtt/mqtt.bob@BOB`. The sequence of events goes like this:

* Alice makes an initial-ticket request to the `ALICE` KDC, requesting a ticket for the `krbtgt/ALICE@ALICE` ticket-granting principal. This request is authenticated (by password or keytab) and Alice gets a TGT for `ALICE`.
* Alice makes a ticket-based request to the `ALICE` KDC, supplying the previous ticket and requesting a ticket for the principal `krbtgt/BOB@ALICE`. This is the cross-realm principal which allows clients from the `ALICE` realm to get tickets for services in the `BOB` realm.
* Alice makes a ticket-based request to the `BOB` KDC, supplying the cross-realm ticket and requesting a ticket for `mqtt/mqtt.bob@BOB`. Because the password for the cross-realm ticket is shared between the two KDCs, the `BOB` KDC can verify that Alice's identity has been vouched for by the `ALICE` KDC, and can issue a ticket for the MQTT server.
* Alice now uses the service ticket to authenticate to the MQTT server. The MQTT server checks its ACLs for `alice@ALICE` and grants Alice appropriate access.

The process becomes more complicated when `ALICE` and `BOB` do not share a key in common, but trust can be established via `CHARLIE`. Such situations need to be carefully considered; allowing `CHARLIE` to vouch for clients in `ALICE` places a very large amount of trust in the `CHARLIE` administrators.
